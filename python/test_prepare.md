# 테스트 대비 노트 정리
## 문자열
---
### 1. 문자열 인덱싱
- 문자열은 메모리상에 각 문자들이 일렬로 저장됨
- 각 개별 문자를 가져오기 위해 활용
- 문자열의 끝 문자의 인뎃스는 -1부터 시작함
- 인덱스 번호는 문자열 길이 범위 안에서만 사용 가능
- 문자열은 문자로 구성된 리스트의 일종으로, 순회를 통해 개발 문자 사용 가능
- 문자열은 변경이 필요한 경우에는 문자열을 새롭게 생성함
```python
a="hello, python!!"
print(a[7],"-",a[-8])
#p-p
print(a[5])
#,
```

### 2. 문자열 슬라이싱
- 문자열[begin: end: step]
- begin: 범위 시작 인덱스로 생략 시 0과 동일
- end: 범위 끝 인덱스로 end 앞의 문자까지 추출, 생략 시 끝까지 추출
- step: 숫자만큼 건너뛰고 추출, 생략 시 1과 동일
```python
a="hello, python!!"
print(a[7:13:1])
#python
```
### 3. 문자열 포메팅
---
- 문자열 안의 특정 값이 변할 경우 사용
- 문자열이 아닌 유형은 str 함수를 활용하여 문자열로 형 변환 후 사용
- 문자열과 다른 유형의 타입을 조합해서 사용하문 방법

**"+"연산자를 사용하는 포메팅**
```python
name="홍길동"
age=30
print("이름: "+name+ "나이: " +str(age))
```
**표식을 사용한 포메팅**
```python
print("이름: %s 나이: %d" %(name, age))
```
**format 함수를 사용한 포메팅**
```python
print("이름: {} 나이: {}".format(name, age))
print("이름: {1} 나이: {0}".format(age, name))
```
**f문자열을 사용한 포메팅**
```python
print(f"이름: {name} 나이: {age}")
```

## 리스트 
---
- 리스트의 정의: 여러 개의 값(정수, 실수, 문자열 등)을 배열 형태로 저장하는 타입
### 1. 리스트 인덱싱
- 표현식 : 리스트_변수명[인덱스]
```python
points=[10,20,"AB",40,3.14,60]
print(points[0])
#10 출력
```

### 2. 리스트 슬라이싱
- 표현식 : 리스트_변수명[begin, end, step]
- begin: 범위 시작 인덱스로 생략 시 0과 동일
- end: 범위 끝 인덱스로 end 앞의 요소까지 추출, 생략 시 끝까지 추출
- step: 숫자만큼 건너띄고 추출, 생략 시 1과 동일
```python
points=[10,20,"AB",40,3.14,60]
print(points[1:5:2])
#20 40 출력
print(points[-3:])
# 40 3.14 60
```
## 튜플
---
### 1. 불변 자료 집합
- 리스트와 유사하지만 초기화 후 요소의 추가, 변경, 삭제 등이 불가함
- 튜플의 선언
```python
tuple_name=(값1,값2,...)
tuple_name=tuple()
tuple_name=(값1,)
tuple_name=tuple((값1,))
```
- 주의 사항: 한 개의 요소를 갖는 튜플을 선언할 경우 요소 옆에 콤파(,)를 추가해야함

## 딕셔너리
---
- 기본 문법: dict_name[검색 key]
- 샘플 코드
  ```python
  print(dict_a["name"])
  print(dict_a["age"])
  print(dict_a["addr"])
  ```
- 순서가 없으므로 index로 검색이 불가하며, key로부터 찾아야함
- key는 내부적으로 정렬되어 있어 key로 검색 시 속도가 상당히 빠름
- key로 찾고자 하는 값이 없을 경우 오류 발생하므로, 예외 처리 구문 필요

## 클래스
---
### 1. 객체 지향 프로그램 특징
- 추상성(Abstraction): 사용자에게 꼭 필요한 부분만 코드로 구현
- 은폐성(Encapsulation): 객체 내부에 로직과 데이터를 숨기고 메서드를 통해서 접근
- 상속성(Inheritance): 공통 분모에 해당되는 부분을 상속받아 사용 가능
- 다형성(Polymorphism): 부모 클래스로 부터 상속받은 메서드와 동일한 이름의 다른 액션 수행 메서드 생성
  - 이름은 같지만 다른 액션을 수행하도록 덮어쓰기(override)함
  
### 함수
---
1. 인수의 기본값
- 함수 호출 시 인수값을 전달하지 않을 경우 인수의 기본값 지정 가능
- 기본값 정의하는 인수는 인수목록의 뒤쪽에 위치해야 함
- 기본값을 가지는 인수의 개수는 제약 없음 

```python
def calsum(a,b=1,c=2):
    return a+b+c

print(calsum(10)) #13
print(calsum(10,20)) #32
print(calsum(10,20,30)) #60
```

2. 키워드 인수
- 함수 호출 시 인수의 수가 많을 경우 순서에 맞춰 전달이 어려울 경우 사용
- 인수의 이름을 지정하여 대입함으로써 순서와 상관없이 전달 가능함
- 위치 인수와 키워드 인수 혼합시에는 위치 인수 뒤에 키워드 인수 작성해야함

```python
def divide(a,b):
    return a/b

print(divide(10,20)) #0.5
print(divide(10,b=20)) #0,5
print(divide(b=20,a=10)) #0.5
print(divide(a=20,10))  #에러 발생
```

3. 가변 인수
- 정의된 인수 개수가 아닌 임의 개수의 인수를 받기 위한 인수
- 매개변수 앞에 * 기호 붙임
- 가변인수는 위치인수 뒤에 작성하며, 1개만 존재 가능함
- 가변인수로 받은 값들을 튜플의 요소로 처리되어 for...in문으로 처리 가능함

```python
def calsum(num, *values):
    sumvalue=0
    for value in values:
        sumvalue+=value
    return sumvalue+num

print(calsum(100)) #100
print(calsum(100,200)) #300
print(calsum(100,200,300,400,500)) #1500
```
4. 키워드 가변 인수
- 여러 개의 키워드 인수 전달 시 인수의 이름과 값을 쌍으로 사전형으로 전달함
- 인수 하나로 여러 개의 키워드 이름과 값을 한번에 받는 것이 가능함
- 매개변수 앞에 **기호 붙임
- 키워드 가변인수는 인수의 마지막에 작성함(위치 인수, 키워드 인수, 키워드 가변인수)
```python
def func_a(**dica):
    print(dica)
    print(type(dica))
    for value in dica.values():
        print(value)

func_a(a=1,b=2,c=3)
```

## 파일
---
### 1. 파일 쓰기
- 파일 오픈: 파일 입출력을 위해 위치를 확인하고 버퍼를 준비하는 과정
```python 
open(파일명) 
close()
```
- 파일 열기 모드

|모드|수행|설명|
|:---:|:---:|:---:|
|r|읽기 모드|파일을 읽기만 할때 사용|
|w|쓰기 모드|파일에 내용을 쓸 때 사용|
|a|추가 모드|파일의 마지막에 새로운 내용을 추가할 때 사용|

### 2.파일 읽기
- 파일 내용을 읽을 경우 파일 내용의 분량에 따라 적당한 함수 사용
- read(): 파일 내용 전체를 한번에 읽는 함수
- readline(): 파일 내용을 한 줄씩 읽고 파일 마지막에 빈 문자열 리턴
- readlines(): 파일 내용 전체를 한번에 읽어 한줄씩 문자열로 만들어 리스트로 리턴

